name: Build ‚ñ∂Ô∏é Push ‚ñ∂Ô∏é Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION:     ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  BACKEND_ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/backend-services
  FRONTEND_ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/frontend-service
  FRONTEND_REPO:  meryembraham/planit-frontend1

jobs:
  build-and-push:
    name: üê≥ Build & Push Docker Images
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service:
          - { name: auth-service,     path: backend/auth,   is_frontend: false }
          - { name: staff-service,    path: backend/staff,  is_frontend: false }
          - { name: event-service,    path: backend/event,  is_frontend: false }
          - { name: frontend-service, path: planit-frontend1, is_frontend: true }
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          path: .

      - name: Checkout frontend (if needed)
        if: matrix.service.is_frontend == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FRONTEND_REPO }}
          token:      ${{ secrets.GITHUB_TOKEN }}
          path:       frontend

      - uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-region:            ${{ secrets.AWS_REGION }}
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push ${{ matrix.service.name }}
        env:
          BACKEND_ECR_REGISTRY: ${{ env.BACKEND_ECR_REGISTRY }}
          FRONTEND_ECR_REGISTRY: ${{ env.FRONTEND_ECR_REGISTRY }}
        run: |
          CONTEXT=${{ matrix.service.path }}

          if [ "${{ matrix.service.is_frontend }}" = "true" ]; then
            IMAGE=$FRONTEND_ECR_REGISTRY:latest
            docker build \
              --build-arg VITE_API_URL="https://${{ secrets.ALB_DNS }}/api" \
              -t $IMAGE $CONTEXT
            docker push $IMAGE
          else
            IMAGE=$BACKEND_ECR_REGISTRY:${{ matrix.service.name }}-latest
            docker build \
              --build-arg DB_HOST="${{ secrets.AURORA_ENDPOINT }}" \
              --build-arg DB_NAME="${{ secrets.AURORA_DB_NAME }}" \
              --build-arg DB_USER="${{ secrets.AURORA_DB_USER }}" \
              --build-arg DB_PASSWORD="${{ secrets.AURORA_DB_PASSWORD }}" \
              -t $IMAGE $CONTEXT
            docker push $IMAGE
          fi

  deploy:
    name: üöÄ Deploy to EKS
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-region:            ${{ secrets.AWS_REGION }}
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name ${{ secrets.EKS_CLUSTER_NAME }} \
            --region ${{ secrets.AWS_REGION }}

      - name: Deploy all services
        run: |
          kubectl apply -f ./deployment/declarative/manifests/base/auth-service
          kubectl apply -f ./deployment/declarative/manifests/base/staff-service
          kubectl apply -f ./deployment/declarative/manifests/base/event-service
          kubectl apply -f ./deployment/declarative/manifests/base/frontend-service

      - name: Wait for LoadBalancers
        run: |
          for svc in auth-service staff-service event-service frontend-service; do
            kubectl wait --for=condition=ready --timeout=10m svc/$svc
          done

      - name: Show external endpoints
        run: |
          kubectl get svc \
            auth-service staff-service event-service frontend-service \
            -o custom-columns=NAME:.metadata.name,ENDPOINT:.status.loadBalancer.ingress[0].hostname
