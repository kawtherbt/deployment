name: Build ‚ñ∂Ô∏é Push ‚ñ∂Ô∏é Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION:     ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  BACKEND_ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/backend-services
  FRONTEND_ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/frontend-service
  FRONTEND_REPO:  meryembraham/planit-frontend1

jobs:
  build-and-push:
    name: üê≥ Build & Push Docker Images
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service:
          - { name: auth-service,     path: backend/auth,   is_frontend: false }
          - { name: staff-service,    path: backend/staff,  is_frontend: false }
          - { name: event-service,    path: backend/event,  is_frontend: false }
          - { name: frontend-service, path: planit-frontend1, is_frontend: true }
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          path: .

      - name: Checkout frontend (if needed)
        if: matrix.service.is_frontend == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.FRONTEND_REPO }}
          token:      ${{ secrets.GITHUB_TOKEN }}
          path:       frontend

      - uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-region:            ${{ secrets.AWS_REGION }}
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push ${{ matrix.service.name }}
        env:
          BACKEND_ECR_REGISTRY: ${{ env.BACKEND_ECR_REGISTRY }}
          FRONTEND_ECR_REGISTRY: ${{ env.FRONTEND_ECR_REGISTRY }}
        run: |
          CONTEXT=${{ matrix.service.path }}

          if [ "${{ matrix.service.is_frontend }}" = "true" ]; then
            IMAGE=$FRONTEND_ECR_REGISTRY:latest
            docker build \
              --build-arg VITE_API_URL="https://${{ secrets.ALB_DNS }}/api" \
              -t $IMAGE $CONTEXT
            docker push $IMAGE
          else
            IMAGE=$BACKEND_ECR_REGISTRY:${{ matrix.service.name }}-latest
            docker build \
              --build-arg DB_HOST="${{ secrets.AURORA_ENDPOINT }}" \
              --build-arg DB_NAME="${{ secrets.AURORA_DB_NAME }}" \
              --build-arg DB_USER="${{ secrets.AURORA_DB_USER }}" \
              --build-arg DB_PASSWORD="${{ secrets.AURORA_DB_PASSWORD }}" \
              -t $IMAGE $CONTEXT
            docker push $IMAGE
          fi
  bootstrap-iam:
      name: ‚òÅÔ∏è Bootstrap IAM Role
      runs-on: ubuntu-latest
      needs: build-and-push
      steps:
        - name: Configure AWS CLI
          uses: aws-actions/configure-aws-credentials@v3
          with:
            aws-region:        ${{ env.AWS_REGION }}
            aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

        - name: Ensure GitHub OIDC provider
          run: |
            PROVIDER_ARN="arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:oidc-provider/token.actions.githubusercontent.com"
            if ! aws iam get-open-id-connect-provider --open-id-connect-provider-arn $PROVIDER_ARN; then
              aws iam create-open-id-connect-provider \
                --url https://token.actions.githubusercontent.com \
                --client-id-list sts.amazonaws.com \
                --thumbprint-list 6938fd4d98bab03faadb97b34396831e3780aea1
            fi

        - name: Create / update deploy role
          run: |
            ROLE_NAME=GitHubDeployRole
            TRUST_POLICY=$(cat <<EOF
            {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Federated": "arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:oidc-provider/token.actions.githubusercontent.com"
                  },
                  "Action": "sts:AssumeRoleWithWebIdentity",
                  "Condition": {
                    "StringLike": {
                      "token.actions.githubusercontent.com:sub": "repo:${{ github.repository }}:*"
                    }
                  }
                }
              ]
            }
            EOF
            )
            echo "$TRUST_POLICY" > trust-policy.json

            if ! aws iam get-role --role-name $ROLE_NAME; then
              aws iam create-role \
                --role-name $ROLE_NAME \
                --assume-role-policy-document file://trust-policy.json
            else
              aws iam update-assume-role-policy \
                --role-name $ROLE_NAME \
                --policy-document file://trust-policy.json
            fi

            aws iam attach-role-policy \
              --role-name $ROLE_NAME \
              --policy-arn arn:aws:iam::aws:policy/AmazonEKSClusterPolicy

            echo "DEPLOY_ROLE_ARN=arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/$ROLE_NAME" >> $GITHUB_ENV

  deploy:
      name: üöÄ Deploy to EKS
      runs-on: ubuntu-latest
      needs:
        - build-and-push
        - bootstrap-iam
      env:
        DEPLOY_ROLE_ARN: ${{ env.DEPLOY_ROLE_ARN }}
        AWS_REGION:      ${{ env.AWS_REGION }}
      steps:
        - name: Assume deploy role
          uses: aws-actions/configure-aws-credentials@v3
          with:
            role-to-assume: ${{ env.DEPLOY_ROLE_ARN }}
            aws-region:     ${{ env.AWS_REGION }}

        - name: Update kubeconfig
          run: |
            aws eks update-kubeconfig \
              --name ${{ secrets.EKS_CLUSTER_NAME }} \
              --region ${{ env.AWS_REGION }}

        - name: Deploy all services
          run: |
            kubectl apply -f deployment/declarative/manifests/base/auth-service
            kubectl apply -f deployment/declarative/manifests/base/staff-service
            kubectl apply -f deployment/declarative/manifests/base/event-service
            kubectl apply -f deployment/declarative/manifests/base/frontend-service

        - name: Wait for LoadBalancers
          run: |
            for svc in auth-service staff-service event-service frontend-service; do
              kubectl wait --for=condition=ready --timeout=10m svc/$svc
            done

        - name: Show external endpoints
          run: |
            kubectl get svc \
              auth-service staff-service event-service frontend-service \
              -o custom-columns=NAME:.metadata.name,ENDPOINT:.status.loadBalancer.ingress[0].hostname