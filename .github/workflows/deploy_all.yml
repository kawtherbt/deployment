name: Build ‚ñ∂Ô∏é Push ‚ñ∂Ô∏é Deploy All Services

on:
  push:
    branches: [ new ]
  workflow_dispatch:

env:
  AWS_REGION:     ${{ secrets.AWS_REGION }}                        # e.g. eu-west-3
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}                  # your 12-digit account
  ECR_REGISTRY:   ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
  EKS_CLUSTER:    ${{ secrets.EKS_CLUSTER_NAME }}                # e.g. planit-eks
  ALB_DNS:        ${{ secrets.ALB_DNS }}                         # e.g. planit-alb-xxxx.elb.amazonaws.com
  AURORA_ENDPOINT: ${{ secrets.AURORA_ENDPOINT }}                # e.g. planit-aurora.cluster-xxx.rds.amazonaws.com
  AURORA_DB_NAME:  ${{ secrets.AURORA_DB_NAME }}
  AURORA_DB_USER:  ${{ secrets.AURORA_DB_USER }}
  AURORA_DB_PASS:  ${{ secrets.AURORA_DB_PASSWORD }}

jobs:
  build-and-push:
    name: üê≥ Build & Push Docker Images
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service:
          - name: auth-service
            repo: meryembraham/planit-auth
            path: backend/auth
            port: 8080
            frontend: false
          - name: staff-service
            repo: meryembraham/planit-staff
            path: backend/staff
            port: 8080
            frontend: false
          - name: event-service
            repo: meryembraham/planit-event
            path: backend/event
            port: 8080
            frontend: false
          - name: frontend-service
            repo: meryembraham/planit-frontend1
            path: frontend
            port: 80
            frontend: true

    steps:
      - name: Checkout deployment repo
        uses: actions/checkout@v4

      - name: Checkout ${{ matrix.service.name }}
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.service.repo }}
          token:      ${{ secrets.GITHUB_TOKEN }}
          path:       ${{ matrix.service.path }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-region:            ${{ env.AWS_REGION }}
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push ${{ matrix.service.name }}
        env:
          IMAGE: ${ECR_REGISTRY}/${{ matrix.service.name }}:latest
        run: |
          echo "Building & pushing $IMAGE from context '${{ matrix.service.path }}'‚Ä¶"
          if [ "${{ matrix.service.frontend }}" = "true" ]; then
            docker build \
              --build-arg VITE_API_URL="https://${ALB_DNS}/api" \
              -t $IMAGE ${{ matrix.service.path }}
          else
            docker build \
              --build-arg DB_HOST="${AURORA_ENDPOINT}" \
              --build-arg DB_NAME="${AURORA_DB_NAME}" \
              --build-arg DB_USER="${AURORA_DB_USER}" \
              --build-arg DB_PASSWORD="${AURORA_DB_PASS}" \
              -t $IMAGE ${{ matrix.service.path }}
          fi
          docker push $IMAGE

  deploy:
    name: üöÄ Deploy to EKS
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-region:            ${{ env.AWS_REGION }}
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name ${{ env.EKS_CLUSTER }} \
            --region ${{ env.AWS_REGION }}

      - name: Deploy all services
        run: |
          kubectl apply -f deployment/declarative/manifests/base/auth-service
          kubectl apply -f deployment/declarative/manifests/base/staff-service
          kubectl apply -f deployment/declarative/manifests/base/event-service
          kubectl apply -f deployment/declarative/manifests/base/frontend-service

      - name: Wait for services
        run: |
          for svc in auth-service staff-service event-service frontend-service; do
            kubectl wait --for=condition=available --timeout=5m deployment/$svc
            kubectl wait --for=condition=ready     --timeout=5m svc/$svc
          done

      - name: Show external endpoints
        run: |
          kubectl get svc auth-service staff-service event-service frontend-service \
            -o custom-columns=NAME:.metadata.name,ENDPOINT:.status.loadBalancer.ingress[0].hostname